<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tiny AI Tools, Big Wins: Automating Cost Report Extraction on Your Laptop in Minutes | Scott Labbe</title>
    <link rel="canonical" href="https://scottlabbe.me/articles/tiny-ai-tools-big-wins/" />
  <meta name="description" content="A practical walkthrough for auditors and program managers to build a local AI-assisted tool that extracts cost report data in minutes." />
  <meta name="article:published" content="2025-11-15" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="Tiny AI Tools, Big Wins: Automating Cost Report Extraction on Your Laptop in Minutes" />
  <meta property="og:description" content="A practical walkthrough for auditors and program managers to build a local AI-assisted tool that extracts cost report data in minutes." />
  <meta property="og:url" content="https://scottlabbe.me/articles/tiny-ai-tools-big-wins/" />
  <meta property="og:site_name" content="Scott Labbe" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Tiny AI Tools, Big Wins: Automating Cost Report Extraction on Your Laptop in Minutes" />
  <meta name="twitter:description" content="A practical walkthrough for auditors and program managers to build a local AI-assisted tool that extracts cost report data in minutes." />
  <script type="application/ld+json">{"@context": "https://schema.org", "@type": "Article", "headline": "Tiny AI Tools, Big Wins: Automating Cost Report Extraction on Your Laptop in Minutes", "description": "A practical walkthrough for auditors and program managers to build a local AI-assisted tool that extracts cost report data in minutes.", "author": {"@type": "Person", "name": "Scott Labbe"}, "mainEntityOfPage": "https://scottlabbe.me/articles/tiny-ai-tools-big-wins/", "url": "https://scottlabbe.me/articles/tiny-ai-tools-big-wins/", "publisher": {"@type": "Person", "name": "Scott Labbe"}, "datePublished": "2025-11-15", "dateModified": "2025-11-15"}</script>
  <meta property="og:image" content="https://scottlabbe.me/articles/tiny-ai-tools-big-wins/images/tinyaitools.png" />
  <meta name="twitter:image" content="https://scottlabbe.me/articles/tiny-ai-tools-big-wins/images/tinyaitools.png" />
<style>
    body {
      margin: 0 auto;
      width: 744px;
      font-family: Source Serif Pro, serif;
      line-height: 32px;
      font-weight: 400;
      color: rgba(0, 0, 0, 0.7);
      font-size: 21px;
    }
    h1, h2, h3 {
      font-family: Source Sans Pro, Helvetica, Arial, sans-serif;
    }
    h1 a, h1 a:visited {
      color: inherit;
      text-decoration: none;
    }
    h1 {
      line-height: 48px;
      font-weight: 600;
      color: rgba(0, 0, 0, 0.85);
      font-size: 42px;
      margin: 32px 0 20px;
    }
    h2 {
      line-height: 32px;
      font-weight: 600;
      color: rgba(0, 0, 0, 0.85);
      font-size: 26px;
      margin: 28px 0;
    }
    h3 {
      line-height: 28px;
      font-weight: 600;
      color: rgba(0, 0, 0, 0.85);
      font-size: 21px;
      margin: 24px 0;
    }
    p {
      margin: 32px 0;
    }
    .created, .published {
      color: rgba(0, 0, 0, 0.55);
      font-size: 15px;
      line-height: 15px;
      margin: 20px 0;
    }
    .created + .published {
      margin-top: -12px;
    }
    blockquote {
      font-family: Georgia, Source Serif Pro, serif;
      font-style: italic;
      font-size: 24px;
      line-height: 36px;
      margin: 48px 120px;
      text-align: center;
    }
    a {
      word-wrap: break-word;
      outline: none;
      text-decoration: none;
      background-color: transparent;
      border: 0;
      color: #008CC9;
    }
    a:hover {
      text-decoration: underline;
    }
    a:visited {
      color: #8C68CB;
    }
    .center {
      text-align: center;
    }
    iframe {
      display: block;
      margin: 44px auto;
    }
    *:not(pre) + pre, pre:first-of-type {
      margin-top: 32px;
      padding-top: 32px;
    }
    pre:only-of-type {
      margin: 32px 0;
      padding: 32px;
    }
    pre {
      background: #F3F6F8;
      overflow-x: auto;
      display: block;
      font-size: 13px;
      font-family: monospace;
      line-height: 13px;
      padding: 0 32px 32px;
      white-space: pre;
    }
    a.embedded {
      background: #F3F6F8;
      display: block;
      padding: 32px;
      margin: 32px 0;
    }
    img {
      height: auto;
      max-width: 100%;
    }
    .slate-image-embed__resize-full-width img {
      width: 100%;
    }
    .series-logo {
      width: 48px;
      height: 48px;
      box-sizing: border-box;
      background-clip: content-box;
      border: 4px solid transparent;
      border-radius: 6px;
      object-fit: scale-down;
      float: left;
    }
    .series-title {
      font-size: 16px;
      font-weight: 600;
      vertical-align: top;
    }
    .series-description {
      color: rgba(0,0,0,.6);
      font-weight: 400;
      font-size: 14px;
      line-height: 20px;
    }
    div {
      margin: 32px 0;
    }
  </style>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&family=Space+Mono:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/assets/css/main.css" />
  <style>
    /* Override article styles to match site design */
    body {
      background-color: #FDF5E6;
      color: #333333;
      font-family: 'Libre Baskerville', serif;
      max-width: 800px !important;
      width: 100% !important;
      margin: 0 auto !important;
      padding: 4rem 2rem !important;
      font-size: 1rem;
      line-height: 1.7;
    }
    h1, h2, h3 {
      font-family: 'Space Mono', monospace;
      color: #333333;
      font-weight: 700;
      letter-spacing: -0.5px;
    }
    h1 { font-size: 2rem; margin: 1.5rem 0 0.8rem 0; }
    h2 { font-size: 1.4rem; margin: 1.2rem 0 0.6rem 0; }
    h3 { font-size: 1.1rem; margin: 1rem 0 0.5rem 0; }
    p { margin: 0 0 1rem 0; }
    a { color: #2D5D4B; text-decoration: none; }
    a:hover { text-decoration: underline; }
    ul, ol { margin: 0.9rem 0; padding-left: 1.5rem; }
    li { margin: 0.3rem 0; line-height: 1.7; }
  </style>
    <style>
    .site-article-nav { margin: 0 0 1.6rem; font-family: "Space Mono", monospace; font-size: 0.95rem; display: flex; gap: 1rem; flex-wrap: wrap; }
    .site-article-nav a { color: #2D5D4B; text-decoration: none; }
    .site-article-nav a:hover { text-decoration: underline; }
    .hero { margin: 0 0 1.25rem; }
    .hero img { display: block; width: 100%; border-radius: 6px; }
  </style>
</head>
<body>
  <nav class="site-article-nav" aria-label="Article navigation">
    <a href="/">Home</a>
    <a href="/articles/">Articles</a>
    <a href="/videos/">Videos</a>
  </nav>
  <figure class="hero">
    <img src="images/tinyaitools.png" alt="Tiny AI Tools, Big Wins: Automating Cost Report Extraction on Your Laptop in Minutes" />
  </figure>
      <h1><a href="https://www.linkedin.com/pulse/tiny-ai-tools-big-wins-automating-cost-report-your-scott-labbe-cpa-qhgde">Tiny AI Tools, Big Wins: Automating Cost Report Extraction on Your Laptop in Minutes</a></h1>
    <p class="created">Created on 2025-11-15 12:50</p>
  <p class="published">Published on 2025-11-15 14:42</p>
  <div><h3>AI Coding Agents for Program Managers and Auditors</h3><p>While everyone is wondering how their job might change because of AI, I’ve been thinking about a simpler question for people who want to control how AI impacts them:</p><p><strong>What kinds of manual, repeatable tasks can be completely automated with AI help right now?</strong></p><p>This post is a case-study about one of those tasks: end-of-year data extraction from a folder of Excel cost reports, the kind many program managers and auditors deal with constantly. Maybe it’s to begin analysis or a reimbursement process, either way, automating an extraction task like this has never been more within reach for non-programmers.</p><hr><h3>The problem: hundreds of spreadsheets, same manual, annoying steps</h3><p>In one of my past roles, we reimbursed local governments for salary costs for staff working in a specific program.</p><p>Every year, the same workflow showed up:</p><ol><li><p>Collect <strong>hundreds of cost report spreadsheets</strong> from entities across the state</p></li><li><p><strong>Extract district and salary data</strong> from specific tabs (e.g., <em>Input Data</em>, <em>Salaries</em>)</p></li><li><p><strong>Compile everything</strong> into a single dataset</p></li><li><p><strong>Export to Excel</strong></p></li></ol><p>Once it was in Excel, we could start processes that actually impacted the program like:</p><ul><li><p>Perform desk reviews to identify adjustments or findings</p></li><li><p>Analyze overall program performance or performance by district</p></li><li><p>Support reimbursement calculations</p></li></ul><p>Nothing about this was intellectually hard. It was just… slow. Manual. Error-prone. These kinds of tasks are perfect for automation.</p><p>So instead of subscribing to some big new AI platform to magically solve it, I used an AI coding agent to build a tiny ETL tool that lives on my laptop, runs in a secure environment, and can be part of suite of program management tools.</p><hr><h3>The idea: small, repeatable wins you actually own</h3><p>I’m using <strong>AI coding agents</strong> (specifically OpenAI’s Codex CLI) to generate small, task-specific tools:</p><ul><li><p>They’re <strong>not</strong> a new subscription or platform</p></li><li><p>They’re <strong>just scripts</strong> you can keep, adjust, and reuse</p></li><li><p>They’re focused on <strong>one workflow at a time</strong></p></li></ul><p>In this case, I set up a folder called program_management that will hold multiple automation tools, with a subfolder called ‘extract’ for this experiment. The extract folder holds a handful of <strong>template-based Excel files</strong>:</p><ul><li><p>Simplified cost report layouts modeled after real programs</p></li><li><p>A couple of tabs per file (e.g., <em>Input Data</em>, <em>Salaries</em>)</p></li><li><p>Fake/synthetic data that behaves like real data, but isn’t confidential or sensitive</p></li></ul><p>These templates stand in for the hundreds of spreadsheets we’d normally see in actual programs.</p><hr><h3>Follow along on YouTube and GitHub</h3><p>I’ve recorded a screen-share walkthrough (bottom of article) showing this exact process with the Codex agent and example files, you can access both below. I’m going to walkthrough using this process to automate more program management and audit processes (e.g. desk reviews, dashboards, and reports) in future videos so let me know if you have any questions or want to see something specific.</p><p><a href="https://youtu.be/kAkkZ_oGTsE" target="_blank">https://youtu.be/kAkkZ_oGTsE</a></p><p><a href="https://github.com/scottlabbe/program_managementx" target="_blank">https://github.com/scottlabbe/program_managementx</a></p><hr><h3>The tools: Codex CLI + VS Code + your file system</h3><p>Here’s the basic stack:</p><ul><li><p><strong>Codex CLI</strong> – an AI coding agent you run from the terminal</p></li><li><p><strong>VS Code</strong> – to browse, edit, and run the generated code</p></li><li><p><strong>Your folders</strong> – the cost report spreadsheets live right on your machine</p></li></ul><p>I run Codex CLI from the terminal inside the program_management folder and give it a prompt like:</p><pre>The purpose of this folder is to build tools for a program manager or auditor. In the extract folder, please:

Inspect the spreadsheets in the extract/test_data folder.
Extract all data from the Input Data and Salaries tabs across all files.
Propose a clean, explicit data schema for the combined dataset.
Implement a script that: reads every file in test_data, normalizes the data into that schema, loads it into a local SQLite database (e.g. cost_reports.db), and exports the combined results to an Excel or CSV file (e.g. combined_cost_reports.xlsx).
Add simple instructions to a RUN.md explaining how to run the scripts in VScode.
Work step-by-step:

First, print the plan for my review.
Wait for approval.
Then create the scripts and any helper modules in the extract folder.</pre><p>Then I let it work. On its own:</p><ul><li><p>Opens the files</p></li><li><p>Inspects the tab structure</p></li><li><p>Proposes a plan</p></li><li><p>Writes the extraction code</p></li><li><p>Creates a database loader</p></li><li><p>Adds an export-to-Excel step</p></li><li><p>Generates tests so we can verify the results</p></li></ul><p>My job is mostly to <strong>read what it’s doing</strong>, approve the plan, and run the tests. I don’t have to hand-write every line of Python, but I still stay in control.</p><hr><h3>Data security: build with fakes, run on the real thing</h3><p>One big point I want to emphasize for anyone working with <strong>sensitive data</strong> (salaries, PII, etc.):</p><ul><li><p>I build and test everything using <strong>synthetic data</strong> that matches the layout of real cost reports.</p></li><li><p>Once I’m happy with the pipeline, I can <strong>point the code at a different folder</strong> on my machine that holds the real cost reports.</p></li><li><p>At that stage, I can run the extractor locally without involving the AI agent at all.</p></li></ul><p>You get the benefit of AI-generated automations <strong>without</strong> handing over actual salary details.</p><hr><h3>What I end up with: a small, focused automation tool</h3><p>By the end of this process, I have a CLI tool for:</p><ol><li><p><strong>Extraction</strong> – pulls data from all relevant tabs across all spreadsheets</p></li><li><p><strong>Schema + database</strong> – loads everything into a SQLite database I can reuse</p></li><li><p><strong>Export</strong> – spits out a clean Excel file for analysis, desk reviews, etc.</p></li><li><p><strong>Testing</strong> – lets me re-check correctness any time I change or extend the pipeline</p></li></ol><p>Because they’re just commands, they’re also friendly for building on top of:</p><ul><li><p>If I ever build a web app or desktop app for this, the “Export” button would basically just <strong>run the same CLI commands</strong> behind the scenes.</p></li><li><p>If I move to a new laptop or new team, I can bring the scripts, point them at a new folder of spreadsheets, and run them again.</p></li></ul><p>No subscription, no platform lock-in (other than a $20 OpenAI subscription), just little utilities we control.</p><hr><h3>Why this matters for auditors and program managers</h3><p>From a program management or audit perspective, this kind of tiny ETL tool can:</p><ul><li><p>Turn a <strong>multi-day manual, error-prone compilation</strong> into a <strong>10-second command</strong></p></li><li><p>Give you a consistent data structure every year (or every quarter)</p></li><li><p>Feed <strong>desk reviews, analytics, dashboards, and future automation</strong></p></li><li><p>Reduce human error in copy-paste-heavy workflows</p></li></ul><p>And more broadly:  <strong>AI will take over tasks before it takes over jobs.</strong></p><p>If you can identify the tasks that are: tedious, repetitive, or rule-based...</p><p>…then AI coding agents are an extremely simple and practical way to start automating them today and actually control how AI impacts your role.</p><hr><p>If you’re an auditor or program manager reading this and thinking, <em>“I have a horrible little process that would be perfect for this”</em>, I’d love to hear about it.</p><p>Drop a comment or message me with:</p><ul><li><p>The kind of files you work with</p></li><li><p>What you’d love to never have to do manually again</p></li></ul><div><iframe allowfullscreen="true" frameborder="0" height="405" src="https://www.linkedin.com/embeds/publishingEmbed.html?articleId=9154176557481381287" width="720"></iframe></div><p></p></div>
</body>
</html>
